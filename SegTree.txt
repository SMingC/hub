struct SegTree {
  int n;
  struct node {
    int l, r;
    int sum, tag;
    node(){};
    node(int l, int r, int sum, int tag) : l(l), r(r), sum(sum), tag(tag){}; 
  }Seg[N << 2];
  void push(int rt) {
    Seg[rt].sum = Seg[rt << 1].sum + Seg[rt << 1 | 1].sum;  
    return ;
  }
  #define len(x) (Seg[x].r - Seg[x].l + 1)
  void push_down(int rt) {
    if(Seg[rt].tag) {
      int lz = Seg[rt].tag;
      Seg[rt].tag = 0;
      Seg[rt << 1].sum += len(rt << 1) * lz;
        Seg[rt << 1].tag += lz;
      Seg[rt << 1 | 1].sum += len(rt << 1 | 1) * lz;
        Seg[rt << 1 | 1].tag += lz;
    }
    return ;
  }
  void init(int cnt) {
    n = cnt;
    function<void(int, int, int)>build = [&](int rt, int l, int r) {
      Seg[rt] = {l, r, 0, 0};
      if(l == r) {
        Seg[rt] = {l, r, a[l], 0};
        return ;
      }
      int mid = (l + r) >> 1;
        build(rt << 1, l, mid);
        build(rt << 1 | 1, mid + 1, r);
      push(rt); 
      return ;
    };
    build(1, 1, n);
  }
  void update(int L, int R, int c) {
    function<void(int, int, int, int, int, int)> change = [&](int rt, int l, int r, int L, int R, int c) -> void{
      if (l > r || r < L || l > R) {
          return;
      }
      if(L <= l && r <= R) {
        Seg[rt].tag += c;
        Seg[rt].sum += len(rt) * c;
        return ;
      }
      push_down(rt);
      int mid = (l + r) >> 1;
      if(mid >= L) {
        change(rt << 1, l, mid, L, R, c);
      }
      if(mid < R) {
        change(rt << 1 | 1, mid + 1, r, L, R, c);
      }
      push(rt);
      return;
    };
    change(1, 1, n, L, R, c);
    return ;
  }
  int query(int L, int R) {
    function<int(int, int, int, int, int)> ask = [&](int rt, int l, int r, int L, int R) -> int{
      if (l > r || r < L || l > R) {
        return 0;
      }
      if(L <= l && r <= R) {
        return Seg[rt].sum;
      }
      push_down(rt);
      int mid = (l + r) >> 1, ans = 0;
      if(mid >= L) {
        ans += ask(rt << 1, l, mid, L, R);
      }
      if(mid < R) {
        ans += ask(rt << 1 | 1, mid + 1, r, L, R);
      }
      push(rt);
      return ans;
    };
    return ask(1, 1, n, L, R);
  }
}tr;