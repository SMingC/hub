{"ast":null,"code":"/*\nLanguage: JSON\nDescription: JSON (JavaScript Object Notation) is a lightweight data-interchange format.\nAuthor: Ivan Sagalaev <maniac@softwaremaniacs.org>\nWebsite: http://www.json.org\nCategory: common, protocols, web\n*/\nfunction json(hljs) {\n  const ATTRIBUTE = {\n    className: 'attr',\n    begin: /\"(\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n    relevance: 1.01\n  };\n  const PUNCTUATION = {\n    match: /[{}[\\],:]/,\n    className: \"punctuation\",\n    relevance: 0\n  };\n  const LITERALS = [\"true\", \"false\", \"null\"]; // NOTE: normally we would rely on `keywords` for this but using a mode here allows us\n  // - to use the very tight `illegal: \\S` rule later to flag any other character\n  // - as illegal indicating that despite looking like JSON we do not truly have\n  // - JSON and thus improve false-positively greatly since JSON will try and claim\n  // - all sorts of JSON looking stuff\n\n  const LITERALS_MODE = {\n    scope: \"literal\",\n    beginKeywords: LITERALS.join(\" \")\n  };\n  return {\n    name: 'JSON',\n    keywords: {\n      literal: LITERALS\n    },\n    contains: [ATTRIBUTE, PUNCTUATION, hljs.QUOTE_STRING_MODE, LITERALS_MODE, hljs.C_NUMBER_MODE, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE],\n    illegal: '\\\\S'\n  };\n}\n\nmodule.exports = json;","map":{"version":3,"names":["json","hljs","ATTRIBUTE","className","begin","relevance","PUNCTUATION","match","LITERALS","LITERALS_MODE","scope","beginKeywords","join","name","keywords","literal","contains","QUOTE_STRING_MODE","C_NUMBER_MODE","C_LINE_COMMENT_MODE","C_BLOCK_COMMENT_MODE","illegal","module","exports"],"sources":["/Users/smc/Documents/200hub/node_modules/highlight.js/lib/languages/json.js"],"sourcesContent":["/*\nLanguage: JSON\nDescription: JSON (JavaScript Object Notation) is a lightweight data-interchange format.\nAuthor: Ivan Sagalaev <maniac@softwaremaniacs.org>\nWebsite: http://www.json.org\nCategory: common, protocols, web\n*/\n\nfunction json(hljs) {\n  const ATTRIBUTE = {\n    className: 'attr',\n    begin: /\"(\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n    relevance: 1.01\n  };\n  const PUNCTUATION = {\n    match: /[{}[\\],:]/,\n    className: \"punctuation\",\n    relevance: 0\n  };\n  const LITERALS = [\n    \"true\",\n    \"false\",\n    \"null\"\n  ];\n  // NOTE: normally we would rely on `keywords` for this but using a mode here allows us\n  // - to use the very tight `illegal: \\S` rule later to flag any other character\n  // - as illegal indicating that despite looking like JSON we do not truly have\n  // - JSON and thus improve false-positively greatly since JSON will try and claim\n  // - all sorts of JSON looking stuff\n  const LITERALS_MODE = {\n    scope: \"literal\",\n    beginKeywords: LITERALS.join(\" \"),\n  };\n\n  return {\n    name: 'JSON',\n    keywords:{\n      literal: LITERALS,\n    },\n    contains: [\n      ATTRIBUTE,\n      PUNCTUATION,\n      hljs.QUOTE_STRING_MODE,\n      LITERALS_MODE,\n      hljs.C_NUMBER_MODE,\n      hljs.C_LINE_COMMENT_MODE,\n      hljs.C_BLOCK_COMMENT_MODE\n    ],\n    illegal: '\\\\S'\n  };\n}\n\nmodule.exports = json;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,IAAT,CAAcC,IAAd,EAAoB;EAClB,MAAMC,SAAS,GAAG;IAChBC,SAAS,EAAE,MADK;IAEhBC,KAAK,EAAE,6BAFS;IAGhBC,SAAS,EAAE;EAHK,CAAlB;EAKA,MAAMC,WAAW,GAAG;IAClBC,KAAK,EAAE,WADW;IAElBJ,SAAS,EAAE,aAFO;IAGlBE,SAAS,EAAE;EAHO,CAApB;EAKA,MAAMG,QAAQ,GAAG,CACf,MADe,EAEf,OAFe,EAGf,MAHe,CAAjB,CAXkB,CAgBlB;EACA;EACA;EACA;EACA;;EACA,MAAMC,aAAa,GAAG;IACpBC,KAAK,EAAE,SADa;IAEpBC,aAAa,EAAEH,QAAQ,CAACI,IAAT,CAAc,GAAd;EAFK,CAAtB;EAKA,OAAO;IACLC,IAAI,EAAE,MADD;IAELC,QAAQ,EAAC;MACPC,OAAO,EAAEP;IADF,CAFJ;IAKLQ,QAAQ,EAAE,CACRd,SADQ,EAERI,WAFQ,EAGRL,IAAI,CAACgB,iBAHG,EAIRR,aAJQ,EAKRR,IAAI,CAACiB,aALG,EAMRjB,IAAI,CAACkB,mBANG,EAORlB,IAAI,CAACmB,oBAPG,CALL;IAcLC,OAAO,EAAE;EAdJ,CAAP;AAgBD;;AAEDC,MAAM,CAACC,OAAP,GAAiBvB,IAAjB"},"metadata":{},"sourceType":"script"}